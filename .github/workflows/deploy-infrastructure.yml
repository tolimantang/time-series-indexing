name: Deploy Infrastructure

on:
  push:
    branches: [main]
    paths:
      - 'backend/sql/flyway/**'
      - '.github/workflows/deploy-infrastructure.yml'
  workflow_dispatch:
    inputs:
      force_migrations:
        description: 'Force run database migrations'
        required: false
        default: 'false'

env:
  AWS_REGION: us-west-1
  EKS_CLUSTER_NAME: financial-cluster
  K8S_NAMESPACE: time-series-indexing

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Create namespace and base secrets
      env:
        DB_HOST: ${{ secrets.DB_HOST }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        FRED_API_KEY: ${{ secrets.FRED_API_KEY }}
        CHROMA_API_KEY: ${{ secrets.CHROMA_API_KEY }}
        CHROMA_TENANT: ${{ secrets.CHROMA_TENANT }}
        CHROMA_DATABASE: ${{ secrets.CHROMA_DATABASE }}
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      run: |
        # Create namespace if it doesn't exist
        kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

        # Create/update all shared secrets
        kubectl create secret generic market-encoder-secrets \
          --from-literal=db-host="$DB_HOST" \
          --from-literal=db-name="$DB_NAME" \
          --from-literal=db-user="$DB_USER" \
          --from-literal=db-password="$DB_PASSWORD" \
          --namespace=${{ env.K8S_NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -

        kubectl create secret generic fred-api-secret \
          --from-literal=api-key="$FRED_API_KEY" \
          --namespace=${{ env.K8S_NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -

        kubectl create secret generic chromadb-secret \
          --from-literal=api-key="$CHROMA_API_KEY" \
          --from-literal=tenant="$CHROMA_TENANT" \
          --from-literal=database="$CHROMA_DATABASE" \
          --from-literal=use-hosted="cloud" \
          --namespace=${{ env.K8S_NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -

        kubectl create secret generic anthropic-secret \
          --from-literal=api-key="$ANTHROPIC_API_KEY" \
          --namespace=${{ env.K8S_NAMESPACE }} \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Check for database migrations
      id: sql-changes
      env:
        DB_HOST: ${{ secrets.DB_HOST }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        FORCE_MIGRATIONS: ${{ github.event.inputs.force_migrations || 'false' }}
      run: |
        echo "ðŸ” Checking for SQL migration changes..."

        # Check if migrations should be forced
        if [ "$FORCE_MIGRATIONS" = "true" ]; then
          echo "sql-changed=true" >> $GITHUB_OUTPUT
          echo "ðŸ”§ Force migrations enabled"
          exit 0
        fi

        # Check for SQL file changes in recent commits
        if git diff --name-only HEAD~1 HEAD | grep -q "backend/sql/flyway/"; then
          echo "sql-changed=true" >> $GITHUB_OUTPUT
          echo "âœ… SQL migration files changed"
        else
          echo "sql-changed=false" >> $GITHUB_OUTPUT
          echo "â„¹ï¸ No SQL migration changes detected"
        fi

    - name: Run database migrations
      if: steps.sql-changes.outputs.sql-changed == 'true'
      run: |
        echo "ðŸ—„ï¸ Running database migrations..."

        # Create migration job
        MIGRATION_JOB_NAME="flyway-migration-$(date +%Y%m%d-%H%M%S)"

        cat > migration-job.yaml << EOF
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: ${MIGRATION_JOB_NAME}
          namespace: ${{ env.K8S_NAMESPACE }}
        spec:
          template:
            spec:
              initContainers:
              - name: git-clone
                image: alpine/git:latest
                command: ["/bin/sh"]
                args:
                  - -c
                  - |
                    git clone https://github.com/tolimantang/time-series-indexing.git /workspace
                    cp -r /workspace/backend/sql/flyway/* /migrations/
                    echo "âœ… Migration files copied"
                    ls -la /migrations/
                volumeMounts:
                - name: migrations-volume
                  mountPath: /migrations
              containers:
              - name: flyway
                image: flyway/flyway:10.15.0
                command: ["/bin/sh"]
                args:
                  - -c
                  - |
                    export FLYWAY_URL="jdbc:postgresql://\${DB_HOST}:\${DB_PORT}/\${DB_NAME}"
                    export FLYWAY_USER="\${DB_USER}"
                    export FLYWAY_PASSWORD="\${DB_PASSWORD}"
                    export FLYWAY_LOCATIONS="filesystem:/migrations"
                    export FLYWAY_BASELINE_ON_MIGRATE=true

                    echo "ðŸš€ Running migrations..."
                    flyway migrate
                    echo "âœ… Migration completed"
                    flyway info
                env:
                - name: DB_HOST
                  valueFrom:
                    secretKeyRef:
                      name: market-encoder-secrets
                      key: db-host
                - name: DB_USER
                  valueFrom:
                    secretKeyRef:
                      name: market-encoder-secrets
                      key: db-user
                - name: DB_NAME
                  valueFrom:
                    secretKeyRef:
                      name: market-encoder-secrets
                      key: db-name
                - name: DB_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: market-encoder-secrets
                      key: db-password
                - name: DB_PORT
                  value: "5432"
                volumeMounts:
                - name: migrations-volume
                  mountPath: /migrations
              volumes:
              - name: migrations-volume
                emptyDir: {}
              restartPolicy: Never
          backoffLimit: 1
        EOF

        # Apply and wait for migration job
        kubectl apply -f migration-job.yaml
        kubectl wait --for=condition=complete job/${MIGRATION_JOB_NAME} -n ${{ env.K8S_NAMESPACE }} --timeout=300s

        # Show logs
        kubectl logs job/${MIGRATION_JOB_NAME} -n ${{ env.K8S_NAMESPACE }}

        # Clean up
        kubectl delete job/${MIGRATION_JOB_NAME} -n ${{ env.K8S_NAMESPACE }}
        echo "âœ… Database migrations completed"

    - name: Skip database migrations
      if: steps.sql-changes.outputs.sql-changed == 'false'
      run: echo "â­ï¸ Skipping database migrations - no SQL changes detected"

  notify:
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: always()
    steps:
    - name: Notify status
      run: |
        if [ "${{ needs.deploy-infrastructure.result }}" = "success" ]; then
          echo "âœ… Infrastructure deployment completed successfully"
          echo "ðŸ“Š Namespace: ${{ env.K8S_NAMESPACE }}"
          echo "ðŸ” Secrets: market-encoder, fred-api, chromadb, anthropic"
          echo "ðŸ—„ï¸ Database migrations: Applied if needed"
        else
          echo "âŒ Infrastructure deployment failed"
          exit 1
        fi