apiVersion: batch/v1
kind: Job
metadata:
  name: get-lunar-patterns
  namespace: time-series-indexing
  labels:
    app: get-lunar-patterns
spec:
  ttlSecondsAfterFinished: 3600
  template:
    metadata:
      labels:
        app: get-lunar-patterns
    spec:
      tolerations:
      - key: CriticalAddonsOnly
        operator: Exists
        effect: NoSchedule
      containers:
      - name: get-patterns
        image: python:3.11-slim
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "🔍 Getting All 5 Lunar Patterns"

          # Install dependencies
          apt-get update && apt-get install -y libpq-dev
          pip install --no-cache-dir psycopg2-binary

          # Create pattern getter
          cat > get_patterns.py << 'EOF'
          import psycopg2
          import os

          def get_all_patterns():
              db_config = {
                  'host': os.environ['DB_HOST'],
                  'user': os.environ['DB_USER'],
                  'database': os.environ['DB_NAME'],
                  'password': os.environ['PGPASSWORD']
              }

              conn = psycopg2.connect(**db_config)
              cursor = conn.cursor()

              query = """
              WITH lunar_events AS (
                  SELECT DISTINCT
                      dc.trade_date as event_date,
                      CONCAT(pa.aspect_type, ' ', pa.planet2) as pattern
                  FROM daily_astrological_conditions dc
                  JOIN daily_planetary_aspects pa ON dc.id = pa.conditions_id
                  WHERE pa.planet1 = 'Moon'
                    AND dc.trade_date >= CURRENT_DATE - INTERVAL '5 years'
                    AND pa.orb <= 3.0
              ),
              price_movements AS (
                  SELECT
                      le.pattern,
                      CASE
                          WHEN p2.close_price > p1.close_price THEN 'up'
                          WHEN p2.close_price < p1.close_price THEN 'down'
                          ELSE 'same'
                      END as direction,
                      ((p2.close_price - p1.close_price) / p1.close_price) * 100 as pct_change
                  FROM lunar_events le
                  JOIN market_data p1 ON p1.trade_date = le.event_date
                      AND p1.symbol = 'CRUDE_OIL_WTI'
                  JOIN market_data p2 ON p2.trade_date = le.event_date + INTERVAL '1 day'
                      AND p2.symbol = 'CRUDE_OIL_WTI'
                  WHERE p1.close_price IS NOT NULL
                    AND p2.close_price IS NOT NULL
                    AND p1.close_price != p2.close_price
              )
              SELECT
                  pattern,
                  direction,
                  COUNT(*) as count,
                  AVG(pct_change) as avg_change
              FROM price_movements
              GROUP BY pattern, direction
              HAVING COUNT(*) >= 3
              ORDER BY pattern, direction
              """

              cursor.execute(query)
              results = cursor.fetchall()

              patterns = {}
              for pattern, direction, count, avg_change in results:
                  if pattern not in patterns:
                      patterns[pattern] = {'up': 0, 'down': 0, 'up_avg': 0, 'down_avg': 0}

                  patterns[pattern][direction] = count
                  patterns[pattern][f"{direction}_avg"] = float(avg_change)

              # Find predictive patterns
              predictive = []
              for pattern, data in patterns.items():
                  total = data['up'] + data['down']
                  if total >= 5:
                      up_rate = data['up'] / total
                      down_rate = data['down'] / total

                      if up_rate >= 0.65:
                          predictive.append({
                              'pattern': f"Moon {pattern}",
                              'prediction': 'BULLISH',
                              'accuracy': up_rate,
                              'occurrences': total,
                              'up_count': data['up'],
                              'down_count': data['down'],
                              'avg_up_move': data['up_avg'],
                              'avg_down_move': data['down_avg']
                          })
                      elif down_rate >= 0.65:
                          predictive.append({
                              'pattern': f"Moon {pattern}",
                              'prediction': 'BEARISH',
                              'accuracy': down_rate,
                              'occurrences': total,
                              'up_count': data['up'],
                              'down_count': data['down'],
                              'avg_up_move': data['up_avg'],
                              'avg_down_move': data['down_avg']
                          })

              predictive.sort(key=lambda x: x['accuracy'], reverse=True)

              print(f"\n🌙 ALL LUNAR PATTERNS (Next-Day Oil Predictions):")
              print("=" * 60)
              print(f"Found {len(predictive)} patterns with ≥65% accuracy")
              print()

              for i, p in enumerate(predictive, 1):
                  direction_emoji = "📈" if p['prediction'] == 'BULLISH' else "📉"
                  print(f"{i}. {p['pattern']} → {p['prediction']} {direction_emoji}")
                  print(f"   Accuracy: {p['accuracy']:.1%}")
                  print(f"   Sample: {p['occurrences']} events (↑{p['up_count']} ↓{p['down_count']})")

                  if p['prediction'] == 'BULLISH':
                      print(f"   Avg Up Move: +{p['avg_up_move']:.2f}%")
                      expected = p['accuracy'] * p['avg_up_move']
                      print(f"   Expected Return: +{expected:.2f}% per signal")
                  else:
                      print(f"   Avg Down Move: {p['avg_down_move']:.2f}%")
                      expected = p['accuracy'] * abs(p['avg_down_move'])
                      print(f"   Expected Return: +{expected:.2f}% (short)")
                  print()

              cursor.close()
              conn.close()
              return predictive

          if __name__ == "__main__":
              patterns = get_all_patterns()
              print(f"🎯 SUMMARY: Found {len(patterns)} profitable lunar patterns!")
          EOF

          # Run the pattern analysis
          python get_patterns.py

        env:
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-host
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-user
        - name: DB_NAME
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-name
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-password

      restartPolicy: Never
  backoffLimit: 1