apiVersion: batch/v1
kind: Job
metadata:
  name: fixed-enhanced-hourly-lunar-backtest
  namespace: time-series-indexing
  labels:
    app: fixed-enhanced-hourly-lunar-backtest
spec:
  ttlSecondsAfterFinished: 3600
  template:
    metadata:
      labels:
        app: fixed-enhanced-hourly-lunar-backtest
    spec:
      tolerations:
      - key: CriticalAddonsOnly
        operator: Exists
        effect: NoSchedule
      containers:
      - name: enhanced-lunar-backtest
        image: python:3.11-slim
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "🌙⏰ Fixed Enhanced Hourly Lunar Backtesting"

          # Install system dependencies including compilation tools
          apt-get update && apt-get install -y \
            gcc \
            g++ \
            make \
            pkg-config \
            libpq-dev \
            git \
            build-essential

          # Install Python dependencies with proper compilation support
          pip install --no-cache-dir psycopg2-binary
          pip install --no-cache-dir --use-pep517 pyswisseph

          # Create the enhanced hourly lunar backtesting script from our proper source
          cat > /app/enhanced_hourly_lunar_tester.py << 'EOF'
          """
          Enhanced Hourly Lunar Backtesting Strategy - Fixed Version
          """

          import psycopg2
          import swisseph as swe
          import os
          import logging
          from datetime import datetime, timedelta, timezone
          from collections import defaultdict
          from psycopg2.extras import execute_values

          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          class EnhancedHourlyLunarBacktester:
              def __init__(self):
                  self.db_config = {
                      'host': os.environ['DB_HOST'],
                      'user': os.environ['DB_USER'],
                      'database': os.environ['DB_NAME'],
                      'password': os.environ['DB_PASSWORD'],
                      'port': int(os.environ.get('DB_PORT', '5432'))
                  }

                  # Initialize Swiss Ephemeris
                  swe.set_ephe_path('/usr/share/swisseph')
                  self.SIGNIFICANT_MOVEMENT_THRESHOLD = 5.0

              def get_lunar_position(self, julian_day):
                  """Get moon's position at specific time"""
                  try:
                      result = swe.calc_ut(julian_day, swe.MOON)
                      longitude = result[0][0]

                      sign_num = int(longitude // 30)
                      signs = ['Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo',
                              'Libra', 'Scorpio', 'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces']
                      zodiac_sign = signs[sign_num]

                      return {
                          'longitude': longitude,
                          'zodiac_sign': zodiac_sign,
                          'position_in_sign': longitude % 30
                      }
                  except Exception as e:
                      logger.error(f"Error calculating lunar position: {e}")
                      return None

              def get_planetary_positions(self, julian_day):
                  """Get positions of all major planets"""
                  planets = {
                      'Sun': swe.SUN, 'Mercury': swe.MERCURY, 'Venus': swe.VENUS,
                      'Mars': swe.MARS, 'Jupiter': swe.JUPITER, 'Saturn': swe.SATURN,
                      'Uranus': swe.URANUS, 'Neptune': swe.NEPTUNE, 'Pluto': swe.PLUTO
                  }

                  positions = {}
                  for planet_name, planet_id in planets.items():
                      try:
                          result = swe.calc_ut(julian_day, planet_id)
                          longitude = result[0][0]
                          sign_num = int(longitude // 30)
                          signs = ['Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo',
                                  'Libra', 'Scorpio', 'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces']

                          positions[planet_name] = {
                              'longitude': longitude,
                              'zodiac_sign': signs[sign_num],
                              'position_in_sign': longitude % 30
                          }
                      except Exception as e:
                          logger.warning(f"Could not get position for {planet_name}: {e}")

                  return positions

              def calculate_aspects(self, moon_long, planet_positions):
                  """Calculate lunar aspects to other planets"""
                  aspects = []
                  aspect_types = {
                      'conjunction': (0, 5), 'sextile': (60, 3), 'square': (90, 5),
                      'trine': (120, 5), 'opposition': (180, 5)
                  }

                  for planet_name, planet_data in planet_positions.items():
                      planet_long = planet_data['longitude']
                      angle_diff = abs(moon_long - planet_long)
                      if angle_diff > 180:
                          angle_diff = 360 - angle_diff

                      for aspect_name, (target_angle, orb) in aspect_types.items():
                          if abs(angle_diff - target_angle) <= orb:
                              aspects.append({
                                  'aspect_type': aspect_name,
                                  'planet': planet_name,
                                  'orb': abs(angle_diff - target_angle),
                                  'planet_sign': planet_data['zodiac_sign']
                              })

                  return aspects

              def dt_to_julian(self, dt):
                  """Convert datetime to Julian day"""
                  year, month, day = dt.year, dt.month, dt.day
                  hour = dt.hour + dt.minute/60.0 + dt.second/3600.0
                  return swe.julday(year, month, day, hour)

              def get_hourly_price_data(self, market_symbol):
                  """Get hourly price data for the specified market"""
                  logger.info(f"Fetching hourly price data for {market_symbol}...")

                  conn = psycopg2.connect(**self.db_config)
                  cursor = conn.cursor()

                  cursor.execute("""
                      SELECT datetime, close_price, open_price, high_price, low_price
                      FROM market_data_intraday
                      WHERE symbol = %s
                        AND interval_type = '1h'
                        AND EXTRACT(dow FROM datetime) BETWEEN 1 AND 5
                        AND EXTRACT(hour FROM datetime) BETWEEN 9 AND 16
                      ORDER BY datetime
                  """, (market_symbol,))

                  data = cursor.fetchall()
                  cursor.close()
                  conn.close()

                  logger.info(f"Found {len(data)} hourly records for {market_symbol}")
                  return data

              def run_enhanced_hourly_analysis(self, market_symbol, display_name):
                  """Run comprehensive hourly lunar analysis with auto-storage"""
                  logger.info(f"🚀 Starting enhanced hourly lunar analysis for {market_symbol}...")

                  hourly_data = self.get_hourly_price_data(market_symbol)
                  if not hourly_data:
                      logger.error(f"No hourly data found for {market_symbol}")
                      return []

                  logger.info(f"Analyzing {len(hourly_data)} hourly price points...")

                  patterns = defaultdict(lambda: {
                      'up': 0, 'down': 0, 'up_avg': 0, 'down_avg': 0,
                      'aspect_type': None, 'moon_sign': None, 'target_planet': None, 'target_sign': None,
                      'first_date': None, 'last_date': None
                  })

                  processed_count = 0
                  # Process each hourly data point
                  for i in range(len(hourly_data) - 1):
                      current_time, current_price, _, _, _ = hourly_data[i]
                      next_time, next_price, _, _, _ = hourly_data[i + 1]

                      price_change = ((next_price - current_price) / current_price) * 100
                      if abs(price_change) < 0.1:
                          continue

                      julian_day = self.dt_to_julian(current_time.replace(tzinfo=timezone.utc))
                      moon_pos = self.get_lunar_position(julian_day)
                      if not moon_pos:
                          continue

                      planet_positions = self.get_planetary_positions(julian_day)
                      aspects = self.calculate_aspects(moon_pos['longitude'], planet_positions)

                      direction = 'up' if price_change > 0 else 'down'

                      # Moon sign patterns
                      moon_sign_pattern = f"Moon in {moon_pos['zodiac_sign']}"
                      self.update_pattern(patterns[moon_sign_pattern], direction, price_change, current_time,
                                        aspect_type='sign_transit', moon_sign=moon_pos['zodiac_sign'])

                      # Aspect patterns
                      for aspect in aspects:
                          basic_pattern = f"Moon {aspect['aspect_type']} {aspect['planet']}"
                          self.update_pattern(patterns[basic_pattern], direction, price_change, current_time,
                                            aspect_type=aspect['aspect_type'], target_planet=aspect['planet'])

                          sign_pattern = f"Moon in {moon_pos['zodiac_sign']} {aspect['aspect_type']} {aspect['planet']} in {aspect['planet_sign']}"
                          self.update_pattern(patterns[sign_pattern], direction, price_change, current_time,
                                            aspect_type=aspect['aspect_type'], moon_sign=moon_pos['zodiac_sign'],
                                            target_planet=aspect['planet'], target_sign=aspect['planet_sign'])

                      processed_count += 1
                      if processed_count % 1000 == 0:
                          logger.info(f"Processed {processed_count} hourly data points...")

                  # Find predictive patterns
                  predictive_patterns = []
                  for pattern_name, data in patterns.items():
                      total = data['up'] + data['down']
                      if total >= 3:
                          up_rate = data['up'] / total
                          down_rate = data['down'] / total

                          if up_rate >= 0.65:
                              predictive_patterns.append({
                                  'pattern_name': pattern_name,
                                  'pattern_type': self.classify_pattern_type(pattern_name),
                                  'prediction': 'BULLISH',
                                  'accuracy_rate': up_rate,
                                  'total_occurrences': total,
                                  'up_count': data['up'],
                                  'down_count': data['down'],
                                  'avg_up_move': float(data['up_avg']),
                                  'avg_down_move': float(data['down_avg']),
                                  'expected_return': up_rate * float(data['up_avg']),
                                  'aspect_type': data['aspect_type'],
                                  'moon_sign': data['moon_sign'],
                                  'target_planet': data['target_planet'],
                                  'target_sign': data['target_sign'],
                                  'first_date': data['first_date'],
                                  'last_date': data['last_date'],
                                  'market_symbol': market_symbol
                              })
                          elif down_rate >= 0.65:
                              predictive_patterns.append({
                                  'pattern_name': pattern_name,
                                  'pattern_type': self.classify_pattern_type(pattern_name),
                                  'prediction': 'BEARISH',
                                  'accuracy_rate': down_rate,
                                  'total_occurrences': total,
                                  'up_count': data['up'],
                                  'down_count': data['down'],
                                  'avg_up_move': float(data['up_avg']),
                                  'avg_down_move': float(data['down_avg']),
                                  'expected_return': down_rate * abs(float(data['down_avg'])),
                                  'aspect_type': data['aspect_type'],
                                  'moon_sign': data['moon_sign'],
                                  'target_planet': data['target_planet'],
                                  'target_sign': data['target_sign'],
                                  'first_date': data['first_date'],
                                  'last_date': data['last_date'],
                                  'market_symbol': market_symbol
                              })

                  # Sort and rank patterns
                  predictive_patterns.sort(key=lambda x: x['accuracy_rate'], reverse=True)
                  for i, pattern in enumerate(predictive_patterns, 1):
                      pattern['accuracy_rank'] = i

                  predictive_patterns.sort(key=lambda x: x['expected_return'], reverse=True)
                  for i, pattern in enumerate(predictive_patterns, 1):
                      pattern['return_rank'] = i

                  self.display_results(predictive_patterns, display_name)
                  stored_count = self.store_patterns_to_db(predictive_patterns, market_symbol)

                  logger.info(f"✅ Enhanced hourly analysis complete: {len(predictive_patterns)} patterns found, {stored_count} stored")
                  return predictive_patterns

              def update_pattern(self, pattern_data, direction, price_change, timestamp, **metadata):
                  """Update pattern tracking data"""
                  pattern_data[direction] += 1

                  if pattern_data[direction] == 1:
                      pattern_data[f'{direction}_avg'] = price_change
                  else:
                      old_avg = pattern_data[f'{direction}_avg']
                      count = pattern_data[direction]
                      pattern_data[f'{direction}_avg'] = (old_avg * (count - 1) + price_change) / count

                  for key, value in metadata.items():
                      if value:
                          pattern_data[key] = value

                  if not pattern_data['first_date'] or timestamp < pattern_data['first_date']:
                      pattern_data['first_date'] = timestamp
                  if not pattern_data['last_date'] or timestamp > pattern_data['last_date']:
                      pattern_data['last_date'] = timestamp

              def classify_pattern_type(self, pattern_name):
                  """Classify pattern type based on name"""
                  if ' in ' in pattern_name and any(aspect in pattern_name.lower() for aspect in ['conjunction', 'sextile', 'square', 'trine', 'opposition']):
                      return 'sign-specific'
                  elif any(aspect in pattern_name.lower() for aspect in ['conjunction', 'sextile', 'square', 'trine', 'opposition']):
                      return 'aspect'
                  else:
                      return 'sign-transit'

              def display_results(self, patterns, display_name):
                  """Display analysis results"""
                  print(f"\\n🌙⏰ {display_name.upper()} ENHANCED HOURLY LUNAR PATTERNS:")
                  print("=" * 70)
                  print(f"Found {len(patterns)} patterns with ≥65% accuracy")

                  if patterns:
                      by_type = defaultdict(list)
                      for p in patterns:
                          by_type[p['pattern_type']].append(p)

                      for pattern_type, type_patterns in by_type.items():
                          print(f"\\n📊 {pattern_type.upper()} patterns: {len(type_patterns)}")
                          top_patterns = sorted(type_patterns, key=lambda x: x['accuracy_rate'], reverse=True)[:3]
                          for i, p in enumerate(top_patterns, 1):
                              emoji = "📈" if p['prediction'] == 'BULLISH' else "📉"
                              print(f"  {i}. {p['pattern_name']} → {p['prediction']} {emoji}")
                              print(f"     {p['accuracy_rate']:.1%} accuracy | {p['expected_return']:.2f}% return | {p['total_occurrences']} events")

              def store_patterns_to_db(self, patterns, market_symbol):
                  """Store patterns to the unified lunar_patterns table"""
                  if not patterns:
                      logger.info(f"No patterns to store for {market_symbol}")
                      return 0

                  conn = psycopg2.connect(**self.db_config)
                  cursor = conn.cursor()

                  cursor.execute("DELETE FROM lunar_patterns WHERE market_symbol = %s", (market_symbol,))
                  logger.info(f"Cleared existing patterns for {market_symbol}")

                  insert_sql = """
                  INSERT INTO lunar_patterns (
                      pattern_name, pattern_type, prediction, accuracy_rate, total_occurrences,
                      up_count, down_count, avg_up_move, avg_down_move, expected_return,
                      aspect_type, moon_sign, target_planet, target_sign,
                      analysis_period_start, analysis_period_end, accuracy_rank, return_rank,
                      market_symbol
                  ) VALUES %s
                  """

                  records = []
                  for pattern in patterns:
                      record = (
                          pattern['pattern_name'], pattern['pattern_type'], pattern['prediction'],
                          pattern['accuracy_rate'], pattern['total_occurrences'],
                          pattern['up_count'], pattern['down_count'],
                          pattern['avg_up_move'], pattern['avg_down_move'], pattern['expected_return'],
                          pattern['aspect_type'], pattern['moon_sign'],
                          pattern['target_planet'], pattern['target_sign'],
                          pattern['first_date'], pattern['last_date'],
                          pattern['accuracy_rank'], pattern['return_rank'], pattern['market_symbol']
                      )
                      records.append(record)

                  execute_values(cursor, insert_sql, records)
                  conn.commit()

                  logger.info(f"✅ Stored {len(records)} patterns for {market_symbol} to lunar_patterns table")
                  cursor.close()
                  conn.close()
                  return len(records)

              def run_complete_analysis(self):
                  """Run analysis for all available markets"""
                  logger.info("🚀 Starting Enhanced Hourly Lunar Analysis with Auto-Storage...")

                  markets = [('PLATINUM_FUTURES', 'Platinum')]
                  total_patterns = 0

                  for market_symbol, display_name in markets:
                      logger.info(f"\\n🎯 Analyzing {display_name}...")
                      patterns = self.run_enhanced_hourly_analysis(market_symbol, display_name)
                      total_patterns += len(patterns)

                  print(f"\\n🎉 ENHANCED HOURLY ANALYSIS COMPLETE:")
                  print(f"Total patterns found and stored: {total_patterns}")
                  print(f"✨ All results automatically stored in lunar_patterns table!")

          if __name__ == "__main__":
              backtest = EnhancedHourlyLunarBacktester()
              backtest.run_complete_analysis()
          EOF

          # Create working directory and run the analysis
          mkdir -p /app
          cd /app
          python enhanced_hourly_lunar_tester.py

        env:
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-host
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-user
        - name: DB_NAME
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-name
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-password
        - name: DB_PORT
          value: "5432"

        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1500m"

      restartPolicy: Never
  backoffLimit: 2