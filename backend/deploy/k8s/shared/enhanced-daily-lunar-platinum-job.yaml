apiVersion: batch/v1
kind: Job
metadata:
  name: enhanced-daily-lunar-platinum
  namespace: time-series-indexing
spec:
  template:
    spec:
      containers:
      - name: enhanced-daily-lunar-tester
        image: python:3.11-slim
        command: ["/bin/bash"]
        args:
          - -c
          - |
            echo "🌙📈 Enhanced Daily Lunar Backtesting (Platinum Futures)"

            # Install dependencies
            apt-get update && apt-get install -y \
              python3 \
              python3-pip \
              libpq-dev \
              gcc \
              && rm -rf /var/lib/apt/lists/*

            # Install Python dependencies
            pip3 install --no-cache-dir psycopg2-binary==2.9.11 yfinance==0.2.18

            # Create the enhanced daily lunar tester script
            cat > enhanced_daily_lunar_platinum.py << 'EOF'
            import os
            import psycopg2
            import yfinance as yf
            from datetime import datetime, timedelta
            from typing import Dict, List, Any, Optional, Tuple
            import logging

            logging.basicConfig(level=logging.INFO)
            logger = logging.getLogger(__name__)

            class EnhancedDailyLunarPlatinumTester:
                def __init__(self):
                    # PostgreSQL connection using environment variables from secrets
                    self.conn = psycopg2.connect(
                        host=os.environ.get('DB_HOST'),
                        database=os.environ.get('DB_NAME'),
                        user=os.environ.get('DB_USER'),
                        password=os.environ.get('DB_PASSWORD'),
                        port=os.environ.get('DB_PORT', '5432')
                    )

                    # Balanced thresholds for daily analysis
                    self.ACCURACY_THRESHOLD = 0.65  # 65% accuracy
                    self.MIN_OCCURRENCES = 5       # 5 minimum occurrences (higher than hourly)

                def get_enhanced_planetary_aspects(self, trade_date: datetime) -> List[Dict]:
                    """Get all planetary aspects WITH the target planet's sign position"""
                    cursor = self.conn.cursor()

                    # Get aspects AND the target planet positions
                    query = """
                    SELECT
                        a.planet1,
                        a.planet2,
                        a.aspect_type,
                        a.orb,
                        a.separating_angle,
                        p.zodiac_sign as target_planet_sign,
                        p.degree_in_sign as target_planet_degree
                    FROM daily_planetary_aspects a
                    JOIN daily_planetary_positions p ON p.planet = a.planet2 AND p.trade_date = a.trade_date
                    WHERE a.trade_date = %s
                      AND a.planet1 = 'Moon'
                      AND a.orb <= 8.0
                    ORDER BY a.orb
                    """

                    cursor.execute(query, (trade_date.date(),))
                    results = cursor.fetchall()
                    cursor.close()

                    aspects = []
                    for planet1, planet2, aspect_type, orb, separating_angle, target_sign, target_degree in results:
                        aspects.append({
                            'planet': planet2,
                            'aspect': aspect_type,
                            'orb': float(orb),
                            'target_sign': target_sign,
                            'target_degree': float(target_degree)
                        })

                    return aspects

                def get_moon_position(self, trade_date: datetime) -> Optional[Dict]:
                    """Get Moon position for a specific date"""
                    cursor = self.conn.cursor()

                    cursor.execute("""
                        SELECT longitude, zodiac_sign, degree_in_sign
                        FROM daily_planetary_positions
                        WHERE planet = 'Moon'
                        AND trade_date = %s
                    """, (trade_date.date(),))

                    result = cursor.fetchone()
                    cursor.close()

                    if result:
                        longitude, zodiac_sign, degree_in_sign = result
                        return {
                            'longitude': float(longitude),
                            'zodiac_sign': zodiac_sign,
                            'degree_in_sign': float(degree_in_sign)
                        }
                    return None

                def get_platinum_daily_data(self) -> List[Tuple]:
                    """Get platinum daily data from our existing database"""
                    logger.info(f"📊 Fetching platinum daily data from database")

                    cursor = self.conn.cursor()

                    # Get daily platinum data from our database
                    # Convert hourly data to daily by getting the last close price of each day
                    query = """
                    WITH daily_closes AS (
                        SELECT
                            DATE(datetime) as trade_date,
                            close_price,
                            ROW_NUMBER() OVER (PARTITION BY DATE(datetime) ORDER BY datetime DESC) as rn
                        FROM market_data_intraday
                        WHERE symbol = 'PLATINUM_FUTURES'
                        AND datetime BETWEEN %s AND %s
                        AND interval_type = '1h'
                    )
                    SELECT trade_date, close_price
                    FROM daily_closes
                    WHERE rn = 1
                    ORDER BY trade_date
                    """

                    start_date = '2023-11-27'
                    end_date = '2024-10-24'

                    cursor.execute(query, (start_date, end_date))
                    results = cursor.fetchall()
                    cursor.close()

                    if not results:
                        logger.error(f"No platinum data found in database for PLATINUM_FUTURES")
                        return []

                    # Convert to list of tuples (datetime, close_price)
                    price_data = []
                    for trade_date, close_price in results:
                        # Convert date to datetime for consistency
                        dt = datetime.combine(trade_date, datetime.min.time())
                        price_data.append((dt, float(close_price)))

                    logger.info(f"✅ Successfully retrieved {len(price_data)} daily price points from database")
                    return price_data

                def analyze_enhanced_daily_patterns(self, symbol: str = 'PL=F') -> List[Dict]:
                    """Analyze enhanced daily lunar patterns with precise timing and positional context"""
                    logger.info(f"🎯 Analyzing ENHANCED daily lunar patterns for {symbol}")

                    # Get daily platinum price data from database
                    price_data = self.get_platinum_daily_data()

                    if not price_data:
                        logger.error(f"No daily price data found for {symbol}")
                        return []

                    logger.info(f"📊 Processing {len(price_data)} daily price points for enhanced analysis")
                    patterns = {}
                    processed_count = 0
                    pattern_hits = 0

                    for i in range(len(price_data) - 1):  # Need next day for prediction
                        current_date, current_price = price_data[i]
                        next_date, next_price = price_data[i + 1]

                        # Skip weekends (Saturday=5, Sunday=6)
                        if current_date.weekday() >= 5:
                            continue

                        # Get Moon position for this date
                        lunar_pos = self.get_moon_position(current_date)
                        if not lunar_pos:
                            continue

                        # Get enhanced aspects with target planet signs
                        aspects = self.get_enhanced_planetary_aspects(current_date)

                        # Calculate next-day price movement
                        price_change = ((next_price - current_price) / current_price) * 100
                        direction = 'up' if price_change > 0.1 else 'down' if price_change < -0.1 else 'flat'

                        if direction == 'flat':
                            continue

                        processed_count += 1

                        # BASIC PATTERNS
                        sign_pattern = f"Moon in {lunar_pos['zodiac_sign']}"
                        if sign_pattern not in patterns:
                            patterns[sign_pattern] = {'up': 0, 'down': 0}
                        patterns[sign_pattern][direction] += 1
                        pattern_hits += 1

                        # ENHANCED POSITIONAL PATTERNS
                        for aspect in aspects:
                            # Basic aspect pattern
                            basic_aspect_pattern = f"Moon {aspect['aspect']} {aspect['planet']}"
                            if basic_aspect_pattern not in patterns:
                                patterns[basic_aspect_pattern] = {'up': 0, 'down': 0}
                            patterns[basic_aspect_pattern][direction] += 1
                            pattern_hits += 1

                            # ENHANCED: Aspect with target planet sign
                            enhanced_aspect_pattern = f"Moon {aspect['aspect']} {aspect['planet']} in {aspect['target_sign']}"
                            if enhanced_aspect_pattern not in patterns:
                                patterns[enhanced_aspect_pattern] = {'up': 0, 'down': 0}
                            patterns[enhanced_aspect_pattern][direction] += 1
                            pattern_hits += 1

                            # ENHANCED: Moon sign + aspect + target planet sign
                            full_context_pattern = f"Moon in {lunar_pos['zodiac_sign']} {aspect['aspect']} {aspect['planet']} in {aspect['target_sign']}"
                            if full_context_pattern not in patterns:
                                patterns[full_context_pattern] = {'up': 0, 'down': 0}
                            patterns[full_context_pattern][direction] += 1
                            pattern_hits += 1

                        # Log progress every 50 processed points
                        if processed_count % 50 == 0:
                            logger.info(f"📊 Processed {processed_count} daily movements, recorded {pattern_hits} pattern occurrences")

                    logger.info(f"📊 Final stats: {processed_count} daily movements, {pattern_hits} pattern occurrences")
                    logger.info(f"📋 Raw patterns found: {len(patterns)}")

                    # Filter and evaluate patterns
                    valid_patterns = []

                    for pattern_name, counts in patterns.items():
                        total = counts['up'] + counts['down']

                        if total >= self.MIN_OCCURRENCES:
                            up_accuracy = counts['up'] / total
                            down_accuracy = counts['down'] / total

                            if up_accuracy >= self.ACCURACY_THRESHOLD:
                                valid_patterns.append({
                                    'pattern': pattern_name,
                                    'predicted_direction': 'up',
                                    'accuracy': up_accuracy,
                                    'occurrences': total,
                                    'up_count': counts['up'],
                                    'down_count': counts['down']
                                })
                            elif down_accuracy >= self.ACCURACY_THRESHOLD:
                                valid_patterns.append({
                                    'pattern': pattern_name,
                                    'predicted_direction': 'down',
                                    'accuracy': down_accuracy,
                                    'occurrences': total,
                                    'up_count': counts['up'],
                                    'down_count': counts['down']
                                })

                    # Sort by accuracy
                    valid_patterns.sort(key=lambda x: x['accuracy'], reverse=True)

                    logger.info(f"✨ Found {len(valid_patterns)} valid enhanced daily lunar patterns for {symbol}")

                    return valid_patterns

                def store_patterns(self, patterns: List[Dict], symbol: str = 'PLATINUM_DAILY'):
                    """Store patterns in lunar_patterns table"""
                    logger.info(f"💾 Storing {len(patterns)} enhanced daily patterns for {symbol}")

                    cursor = self.conn.cursor()

                    for pattern in patterns:
                        cursor.execute("""
                            INSERT INTO lunar_patterns
                            (pattern_name, pattern_type, prediction, accuracy_rate,
                             total_occurrences, up_count, down_count, expected_return,
                             market_symbol, created_at)
                            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                            ON CONFLICT (pattern_name, market_symbol)
                            DO UPDATE SET
                                accuracy_rate = EXCLUDED.accuracy_rate,
                                total_occurrences = EXCLUDED.total_occurrences,
                                up_count = EXCLUDED.up_count,
                                down_count = EXCLUDED.down_count,
                                created_at = EXCLUDED.created_at
                        """, (
                            pattern['pattern'],
                            'enhanced_daily_lunar_transit',
                            pattern['predicted_direction'],
                            round(pattern['accuracy'], 3),
                            pattern['occurrences'],
                            pattern['up_count'],
                            pattern['down_count'],
                            0.0,  # expected_return placeholder
                            symbol,
                            datetime.now()
                        ))

                    self.conn.commit()
                    cursor.close()
                    logger.info(f"✅ Successfully stored {len(patterns)} enhanced daily patterns")

                def run_analysis(self):
                    """Run the complete enhanced daily lunar analysis"""
                    logger.info("🚀 Starting ENHANCED Daily Lunar Backtesting Analysis")

                    try:
                        # Analyze platinum futures with daily precision using enhanced positional patterns
                        patterns = self.analyze_enhanced_daily_patterns('PLATINUM')

                        if patterns:
                            # Store results
                            self.store_patterns(patterns, 'PLATINUM_DAILY')

                            # Display top patterns
                            logger.info("🏆 Top Enhanced Daily Lunar Patterns:")
                            for i, pattern in enumerate(patterns[:20], 1):
                                logger.info(f"{i:2d}. {pattern['pattern']:<60} → {pattern['predicted_direction']:<4} "
                                          f"({pattern['accuracy']:.1%} accuracy, {pattern['occurrences']:2d} occurrences)")

                            logger.info(f"\n📈 Summary: Found {len(patterns)} predictive enhanced daily patterns with ≥{self.ACCURACY_THRESHOLD:.0%} accuracy")
                        else:
                            logger.warning("No significant enhanced daily lunar patterns found")

                        logger.info("🎯 Enhanced daily lunar analysis completed successfully!")

                    except Exception as e:
                        logger.error(f"Analysis failed: {e}")
                        raise
                    finally:
                        if self.conn:
                            self.conn.close()

            if __name__ == "__main__":
                tester = EnhancedDailyLunarPlatinumTester()
                tester.run_analysis()
            EOF

            # Run the enhanced daily lunar tester
            echo "🌙📈 Starting Enhanced Daily Lunar Analysis with precise timing..."
            python3 enhanced_daily_lunar_platinum.py
        env:
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-host
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-user
        - name: DB_NAME
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-name
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-password
        - name: DB_PORT
          value: "5432"
        resources:
          requests:
            memory: "500Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
      restartPolicy: Never
  backoffLimit: 2