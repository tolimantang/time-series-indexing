---
# ConfigMap containing Flyway configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: flyway-config
  namespace: time-series-indexing
data:
  flyway.conf: |
    # Flyway configuration for time-series-indexing database
    flyway.baselineOnMigrate=true
    flyway.baselineVersion=0
    flyway.baselineDescription=Pre-Flyway baseline
    flyway.schemas=public
    flyway.table=flyway_schema_history
    flyway.validateOnMigrate=true
    flyway.cleanOnValidationError=false
    flyway.outOfOrder=false
    flyway.placeholderReplacement=false

---
# ConfigMap containing migration files
apiVersion: v1
kind: ConfigMap
metadata:
  name: flyway-migrations
  namespace: time-series-indexing
data:
  V001__initial_schema.sql: |
    -- Initial schema for time-series-indexing database
    -- This represents the current state of the database before Flyway management

    -- Market data tables
    CREATE TABLE IF NOT EXISTS market_data_intraday (
        id SERIAL PRIMARY KEY,
        symbol VARCHAR(50) NOT NULL,
        datetime TIMESTAMP WITH TIME ZONE NOT NULL,
        interval_type VARCHAR(10) NOT NULL,
        open_price DECIMAL(12,6),
        high_price DECIMAL(12,6),
        low_price DECIMAL(12,6),
        close_price DECIMAL(12,6) NOT NULL,
        volume INTEGER,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        UNIQUE(symbol, datetime, interval_type)
    );

    CREATE INDEX IF NOT EXISTS idx_market_data_intraday_symbol_datetime ON market_data_intraday(symbol, datetime);
    CREATE INDEX IF NOT EXISTS idx_market_data_intraday_datetime ON market_data_intraday(datetime);

    -- Astrological data tables
    CREATE TABLE IF NOT EXISTS daily_planetary_positions (
        id SERIAL PRIMARY KEY,
        trade_date DATE NOT NULL,
        planet VARCHAR(20) NOT NULL,
        longitude DECIMAL(8,5) NOT NULL,
        latitude DECIMAL(8,5),
        distance DECIMAL(12,8),
        speed DECIMAL(8,5),
        zodiac_sign VARCHAR(20) NOT NULL,
        degree_in_sign DECIMAL(5,2) NOT NULL,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        UNIQUE(trade_date, planet)
    );

    CREATE INDEX IF NOT EXISTS idx_daily_planetary_positions_date_planet ON daily_planetary_positions(trade_date, planet);
    CREATE INDEX IF NOT EXISTS idx_daily_planetary_positions_planet_sign ON daily_planetary_positions(planet, zodiac_sign);

    CREATE TABLE IF NOT EXISTS daily_planetary_aspects (
        id SERIAL PRIMARY KEY,
        trade_date DATE NOT NULL,
        planet1 VARCHAR(20) NOT NULL,
        planet2 VARCHAR(20) NOT NULL,
        aspect_type VARCHAR(20) NOT NULL,
        orb DECIMAL(5,2) NOT NULL,
        exactness DECIMAL(5,4),
        separating_angle DECIMAL(8,5),
        applying_separating VARCHAR(10),
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        UNIQUE(trade_date, planet1, planet2, aspect_type)
    );

    CREATE INDEX IF NOT EXISTS idx_daily_planetary_aspects_date ON daily_planetary_aspects(trade_date);
    CREATE INDEX IF NOT EXISTS idx_daily_planetary_aspects_planets ON daily_planetary_aspects(planet1, planet2);
    CREATE INDEX IF NOT EXISTS idx_daily_planetary_aspects_type ON daily_planetary_aspects(aspect_type);

    -- Insights and recommendations tables
    CREATE TABLE IF NOT EXISTS astrological_insights (
        id SERIAL PRIMARY KEY,
        insight_type VARCHAR(50) NOT NULL,
        category VARCHAR(50) NOT NULL,
        pattern_name VARCHAR(100) NOT NULL,
        description TEXT NOT NULL,
        confidence_score DOUBLE PRECISION,
        success_rate DOUBLE PRECISION,
        avg_profit DOUBLE PRECISION,
        trade_count INTEGER,
        evidence JSONB,
        claude_analysis TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_astrological_insights_category ON astrological_insights(category);
    CREATE INDEX IF NOT EXISTS idx_astrological_insights_pattern ON astrological_insights(pattern_name);

    CREATE TABLE IF NOT EXISTS daily_astrological_conditions (
        id SERIAL PRIMARY KEY,
        trade_date DATE NOT NULL UNIQUE,
        planetary_positions JSONB NOT NULL,
        major_aspects JSONB,
        lunar_phase_name VARCHAR(50),
        lunar_phase_angle DOUBLE PRECISION,
        significant_events TEXT[],
        daily_score DOUBLE PRECISION,
        market_outlook TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );

    CREATE INDEX IF NOT EXISTS idx_daily_astrological_conditions_date ON daily_astrological_conditions(trade_date);

    CREATE TABLE IF NOT EXISTS daily_trading_recommendations (
        id SERIAL PRIMARY KEY,
        recommendation_date DATE NOT NULL,
        symbol VARCHAR(25) NOT NULL,
        recommendation_type VARCHAR(20) NOT NULL,
        confidence DOUBLE PRECISION NOT NULL,
        astrological_reasoning TEXT,
        supporting_insights INTEGER[],
        target_price DOUBLE PRECISION,
        stop_loss DOUBLE PRECISION,
        holding_period_days INTEGER,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        UNIQUE(recommendation_date, symbol, recommendation_type)
    );

    CREATE INDEX IF NOT EXISTS idx_daily_trading_recommendations_date_symbol ON daily_trading_recommendations(recommendation_date, symbol);

    -- Note: lunar_patterns table will be handled in V005 and V004 migrations

  V005__fix_lunar_patterns_data_issues.sql: |
    -- Migration: Fix lunar patterns data issues
    -- Created: 2025-10-25
    -- Version: V005

    -- This migration addresses data quality issues in the existing lunar_patterns table
    -- before we can apply the clean schema (V004)

    -- Step 1: Create a properly typed backup table
    CREATE TABLE IF NOT EXISTS lunar_patterns_temp_backup AS
    SELECT
        id,
        pattern_name,
        pattern_type,

        -- Clean up prediction field (convert bearish/bullish to down/up)
        CASE
            WHEN LOWER(prediction) IN ('bearish', 'bear', 'down', 'sell') THEN 'down'
            WHEN LOWER(prediction) IN ('bullish', 'bull', 'up', 'buy') THEN 'up'
            ELSE 'unknown'
        END as clean_prediction,

        -- Clean up accuracy_rate field (handle text values)
        CASE
            WHEN accuracy_rate ~ '^[0-9]*\.?[0-9]+$' THEN accuracy_rate::DECIMAL(5,3)
            WHEN LOWER(accuracy_rate) LIKE '%high%' THEN 0.800
            WHEN LOWER(accuracy_rate) LIKE '%medium%' THEN 0.650
            WHEN LOWER(accuracy_rate) LIKE '%low%' THEN 0.550
            ELSE 0.500
        END as clean_accuracy_rate,

        -- Ensure integer fields are properly typed
        COALESCE(total_occurrences, 0) as clean_total_occurrences,
        COALESCE(up_count, 0) as clean_up_count,
        COALESCE(down_count, 0) as clean_down_count,

        -- Ensure decimal fields are properly typed
        COALESCE(avg_up_move, 0) as clean_avg_up_move,
        COALESCE(avg_down_move, 0) as clean_avg_down_move,
        COALESCE(expected_return, 0) as clean_expected_return,

        -- Keep other fields as-is
        aspect_type,
        moon_sign,
        target_planet,
        target_sign,
        COALESCE(minimum_orb, 3.0) as clean_minimum_orb,
        market_symbol,
        analysis_period_start,
        analysis_period_end,
        created_at

    FROM lunar_patterns
    WHERE EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'lunar_patterns');

    -- Step 2: Show data cleaning summary
    DO $$
    DECLARE
        original_count INTEGER;
        cleaned_count INTEGER;
        bad_predictions INTEGER;
        bad_accuracy_rates INTEGER;
    BEGIN
        -- Count original records
        SELECT COUNT(*) INTO original_count FROM lunar_patterns WHERE EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'lunar_patterns');

        -- Count cleaned records
        SELECT COUNT(*) INTO cleaned_count FROM lunar_patterns_temp_backup;

        -- Count records that needed prediction cleaning
        SELECT COUNT(*) INTO bad_predictions
        FROM lunar_patterns
        WHERE LOWER(prediction) NOT IN ('up', 'down')
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'lunar_patterns');

        -- Count records that needed accuracy rate cleaning
        SELECT COUNT(*) INTO bad_accuracy_rates
        FROM lunar_patterns
        WHERE accuracy_rate !~ '^[0-9]*\.?[0-9]+$'
        AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'lunar_patterns');

        RAISE NOTICE 'Data cleaning summary:';
        RAISE NOTICE '  - Original records: %', COALESCE(original_count, 0);
        RAISE NOTICE '  - Cleaned records: %', COALESCE(cleaned_count, 0);
        RAISE NOTICE '  - Fixed bad predictions: %', COALESCE(bad_predictions, 0);
        RAISE NOTICE '  - Fixed bad accuracy rates: %', COALESCE(bad_accuracy_rates, 0);
    END $$;

    -- Step 3: Replace the original table with cleaned data
    DO $$
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'lunar_patterns') THEN
            DROP TABLE lunar_patterns;
            RAISE NOTICE 'Dropped original lunar_patterns table with dirty data';
        END IF;

        -- Rename backup to original name
        ALTER TABLE lunar_patterns_temp_backup RENAME TO lunar_patterns_backup_clean;
        RAISE NOTICE 'Created clean backup table: lunar_patterns_backup_clean';
    END $$;

  V006__create_clean_lunar_patterns_schema.sql: |
    -- Migration: Create clean lunar_patterns table schema
    -- Purpose: Create the final clean schema for lunar patterns
    -- This replaces the problematic V004 migration

    -- Create new clean lunar_patterns table
    CREATE TABLE lunar_patterns (
        id SERIAL PRIMARY KEY,

        -- Core pattern identification
        pattern_name VARCHAR(255) NOT NULL,
        pattern_type VARCHAR(50) NOT NULL DEFAULT 'lunar_transit',
        timing_type VARCHAR(20) NOT NULL CHECK (timing_type IN ('same_day', 'next_day')),

        -- Prediction and accuracy
        prediction VARCHAR(10) NOT NULL CHECK (prediction IN ('up', 'down')),
        accuracy_rate DECIMAL(5,3) NOT NULL CHECK (accuracy_rate >= 0 AND accuracy_rate <= 1),

        -- Occurrence statistics
        total_occurrences INTEGER NOT NULL DEFAULT 0,
        up_count INTEGER NOT NULL DEFAULT 0,
        down_count INTEGER NOT NULL DEFAULT 0,

        -- Price movement statistics
        avg_up_move DECIMAL(8,4) DEFAULT 0,
        avg_down_move DECIMAL(8,4) DEFAULT 0,
        expected_return DECIMAL(8,4) DEFAULT 0,

        -- Astrological context
        aspect_type VARCHAR(50),
        moon_sign VARCHAR(20),
        target_planet VARCHAR(20),
        target_sign VARCHAR(20),
        minimum_orb DECIMAL(4,2) DEFAULT 3.0,

        -- Market and analysis context
        market_symbol VARCHAR(50) NOT NULL,
        analysis_period_start DATE,
        analysis_period_end DATE,

        -- Quality metrics
        accuracy_rank INTEGER,
        return_rank INTEGER,

        -- Metadata
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

        -- Constraints
        UNIQUE(pattern_name, market_symbol, timing_type),
        CHECK (up_count + down_count = total_occurrences)
    );

    -- Create indexes
    CREATE INDEX idx_lunar_patterns_market_timing ON lunar_patterns(market_symbol, timing_type);
    CREATE INDEX idx_lunar_patterns_accuracy ON lunar_patterns(accuracy_rate DESC);
    CREATE INDEX idx_lunar_patterns_expected_return ON lunar_patterns(expected_return DESC);
    CREATE INDEX idx_lunar_patterns_pattern_name ON lunar_patterns(pattern_name);

    -- Create updated_at trigger function
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ language 'plpgsql';

    -- Create trigger
    CREATE TRIGGER update_lunar_patterns_updated_at
        BEFORE UPDATE ON lunar_patterns
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column();

    -- Migrate clean data from backup if it exists
    INSERT INTO lunar_patterns (
        pattern_name,
        pattern_type,
        timing_type,
        prediction,
        accuracy_rate,
        total_occurrences,
        up_count,
        down_count,
        avg_up_move,
        avg_down_move,
        expected_return,
        aspect_type,
        moon_sign,
        target_planet,
        target_sign,
        minimum_orb,
        market_symbol,
        analysis_period_start,
        analysis_period_end,
        created_at
    )
    SELECT
        pattern_name,
        'lunar_transit' as pattern_type,
        'next_day' as timing_type,  -- Assume next_day for existing patterns
        clean_prediction as prediction,
        clean_accuracy_rate as accuracy_rate,
        clean_total_occurrences as total_occurrences,
        clean_up_count as up_count,
        clean_down_count as down_count,
        clean_avg_up_move as avg_up_move,
        clean_avg_down_move as avg_down_move,
        clean_expected_return as expected_return,
        aspect_type,
        moon_sign,
        target_planet,
        target_sign,
        clean_minimum_orb as minimum_orb,
        market_symbol,
        analysis_period_start,
        analysis_period_end,
        created_at
    FROM lunar_patterns_backup_clean
    WHERE clean_prediction IN ('up', 'down')
        AND clean_accuracy_rate > 0
        AND clean_total_occurrences > 0;

    -- Create view for best patterns
    CREATE OR REPLACE VIEW best_lunar_patterns AS
    SELECT
        pattern_name,
        timing_type,
        prediction,
        accuracy_rate,
        expected_return,
        total_occurrences,
        market_symbol,
        aspect_type,
        moon_sign,
        target_planet,
        target_sign,
        ROW_NUMBER() OVER (
            PARTITION BY market_symbol, timing_type
            ORDER BY accuracy_rate DESC, expected_return DESC
        ) as rank
    FROM lunar_patterns
    WHERE accuracy_rate >= 0.65
    ORDER BY market_symbol, timing_type, accuracy_rate DESC;

---
# Job to run Flyway migrations
apiVersion: batch/v1
kind: Job
metadata:
  name: flyway-migration-updated
  namespace: time-series-indexing
spec:
  template:
    spec:
      containers:
      - name: flyway
        image: flyway/flyway:10.15.0
        command: ["/bin/sh"]
        args:
          - -c
          - |
            echo "üõ†Ô∏è  Running Flyway migrations with data fixes..."

            # Set up Flyway configuration from environment
            export FLYWAY_URL="jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}"
            export FLYWAY_USER="${DB_USER}"
            export FLYWAY_PASSWORD="${DB_PASSWORD}"
            export FLYWAY_LOCATIONS="filesystem:/migrations"
            export FLYWAY_CONFIG_FILES="/config/flyway.conf"

            echo "üìä Database: ${FLYWAY_URL}"
            echo "üìÅ Migrations location: ${FLYWAY_LOCATIONS}"
            echo "‚öôÔ∏è  Config file: ${FLYWAY_CONFIG_FILES}"

            # Show migration files
            echo "üìã Available migrations:"
            ls -la /migrations/

            # Show current schema state
            echo "üîç Checking current schema state..."
            flyway info || echo "‚ö†Ô∏è  Schema history table doesn't exist yet"

            # Run migrations
            echo "üöÄ Running migrations..."
            flyway migrate

            # Show final state
            echo "‚úÖ Migration completed! Final state:"
            flyway info

        env:
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-host
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-user
        - name: DB_NAME
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-name
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-password
        - name: DB_PORT
          value: "5432"
        volumeMounts:
        - name: migrations-volume
          mountPath: /migrations
        - name: config-volume
          mountPath: /config
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "200m"

      volumes:
      - name: migrations-volume
        configMap:
          name: flyway-migrations
      - name: config-volume
        configMap:
          name: flyway-config

      restartPolicy: Never
  backoffLimit: 1