---
# Simple deployment without git-sync for local testing
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backtesting-service
  namespace: time-series-indexing
  labels:
    app: backtesting-service
    version: v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backtesting-service
  template:
    metadata:
      labels:
        app: backtesting-service
        version: v1
    spec:
      containers:
      - name: backtesting-service
        image: python:3.11-slim
        ports:
        - containerPort: 8000
          name: http
          protocol: TCP
        command: ["/bin/bash"]
        args:
          - -c
          - |
            echo "🚀 Starting Backtesting Service (Simple Version)..."

            # Install system dependencies
            apt-get update && apt-get install -y \
              libpq-dev \
              gcc \
              curl \
              && rm -rf /var/lib/apt/lists/*

            # Install Python dependencies
            pip install --no-cache-dir \
              fastapi==0.104.1 \
              uvicorn[standard]==0.24.0 \
              pydantic==2.5.0 \
              psycopg2-binary==2.9.9 \
              python-json-logger==2.0.7

            # Create app directory
            mkdir -p /app/llm_analyzer

            # Create minimal backtesting service
            cat > /app/backtesting_service.py << 'PYTHON_EOF'
            #!/usr/bin/env python3
            import os
            import sys
            import logging
            from datetime import datetime
            from typing import Optional, Dict, Any
            from pydantic import BaseModel, Field
            from fastapi import FastAPI, HTTPException, BackgroundTasks
            import psycopg2

            logging.basicConfig(level=logging.INFO)
            logger = logging.getLogger(__name__)

            app = FastAPI(
                title="Backtesting Service",
                description="Lunar pattern backtesting service",
                version="1.0.0"
            )

            class BacktestRequest(BaseModel):
                symbol: str = Field(..., description="Market symbol")
                market_name: str = Field(..., description="Market name")
                timing_type: str = Field(default="next_day", description="Timing type")
                accuracy_threshold: Optional[float] = Field(0.65)
                min_occurrences: Optional[int] = Field(5)

            class BacktestResponse(BaseModel):
                request_id: str
                status: str
                message: str
                patterns_found: Optional[int] = None
                best_pattern: Optional[Dict[str, Any]] = None
                execution_time_seconds: Optional[float] = None

            active_requests: Dict[str, Dict] = {}

            def get_db_connection():
                return psycopg2.connect(
                    host=os.getenv('DB_HOST', 'localhost'),
                    port=os.getenv('DB_PORT', '5432'),
                    database=os.getenv('DB_NAME', 'financial_postgres'),
                    user=os.getenv('DB_USER', 'postgres'),
                    password=os.getenv('DB_PASSWORD', '')
                )

            @app.get("/")
            async def root():
                return {
                    "service": "Backtesting Service",
                    "status": "running",
                    "version": "1.0.0",
                    "active_requests": len(active_requests)
                }

            @app.get("/health")
            async def health_check():
                try:
                    conn = get_db_connection()
                    conn.close()
                    return {"status": "healthy", "database": "connected"}
                except Exception as e:
                    logger.error(f"Health check failed: {e}")
                    raise HTTPException(status_code=503, detail=f"Service unhealthy: {e}")

            @app.post("/backtest", response_model=BacktestResponse)
            async def run_backtest(request: BacktestRequest, background_tasks: BackgroundTasks):
                if request.timing_type not in ['same_day', 'next_day']:
                    raise HTTPException(status_code=400, detail="timing_type must be 'same_day' or 'next_day'")

                request_id = f"{request.symbol}_{request.timing_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

                active_requests[request_id] = {
                    "status": "starting",
                    "request": request.dict(),
                    "start_time": datetime.now()
                }

                background_tasks.add_task(execute_backtest, request_id, request)

                return BacktestResponse(
                    request_id=request_id,
                    status="accepted",
                    message=f"Backtesting started for {request.market_name} ({request.timing_type})"
                )

            @app.get("/backtest/{request_id}", response_model=BacktestResponse)
            async def get_backtest_status(request_id: str):
                if request_id not in active_requests:
                    raise HTTPException(status_code=404, detail="Request not found")

                request_info = active_requests[request_id]
                return BacktestResponse(
                    request_id=request_id,
                    status=request_info["status"],
                    message=request_info.get("message", ""),
                    patterns_found=request_info.get("patterns_found"),
                    best_pattern=request_info.get("best_pattern"),
                    execution_time_seconds=request_info.get("execution_time")
                )

            @app.get("/requests")
            async def list_active_requests():
                return {
                    "active_requests": len(active_requests),
                    "requests": [
                        {
                            "request_id": req_id,
                            "status": info["status"],
                            "symbol": info["request"]["symbol"],
                            "timing_type": info["request"]["timing_type"],
                            "start_time": info["start_time"].isoformat()
                        }
                        for req_id, info in active_requests.items()
                    ]
                }

            @app.get("/patterns/summary")
            async def get_patterns_summary():
                try:
                    conn = get_db_connection()
                    cursor = conn.cursor()
                    cursor.execute("""
                        SELECT
                            market_symbol,
                            timing_type,
                            COUNT(*) as total_patterns,
                            MAX(accuracy_rate) as best_accuracy,
                            (SELECT pattern_name FROM lunar_patterns lp2
                             WHERE lp2.market_symbol = lp.market_symbol
                             AND lp2.timing_type = lp.timing_type
                             ORDER BY accuracy_rate DESC LIMIT 1) as best_pattern_name
                        FROM lunar_patterns lp
                        GROUP BY market_symbol, timing_type
                        ORDER BY market_symbol, timing_type
                    """)

                    results = cursor.fetchall()
                    cursor.close()
                    conn.close()

                    summaries = []
                    for market_symbol, timing_type, total_patterns, best_accuracy, best_pattern_name in results:
                        summaries.append({
                            "symbol": market_symbol,
                            "market_name": market_symbol.replace('_DAILY', '').replace('_FUTURES', ''),
                            "timing_type": timing_type,
                            "total_patterns": total_patterns,
                            "best_accuracy": float(best_accuracy) if best_accuracy else 0.0,
                            "best_pattern_name": best_pattern_name or "None",
                            "analysis_date": datetime.now().date().isoformat()
                        })

                    return {"summaries": summaries}

                except Exception as e:
                    logger.error(f"Failed to get pattern summary: {e}")
                    raise HTTPException(status_code=500, detail=f"Database error: {e}")

            async def execute_backtest(request_id: str, request: BacktestRequest):
                try:
                    active_requests[request_id]["status"] = "running"
                    active_requests[request_id]["message"] = "Running simplified lunar pattern analysis..."

                    logger.info(f"🚀 Starting backtest {request_id}: {request.symbol} ({request.timing_type})")

                    # Simulate analysis time
                    import time
                    start_time = datetime.now()
                    time.sleep(2)  # Simulate 2 seconds of analysis

                    # Insert test pattern for demonstration
                    conn = get_db_connection()
                    cursor = conn.cursor()

                    # Insert a test pattern
                    cursor.execute("""
                        INSERT INTO lunar_patterns (
                            market_symbol, timing_type, pattern_name,
                            accuracy_rate, total_occurrences, up_count, down_count,
                            prediction, pattern_type, aspect_type, target_planet,
                            target_sign, moon_sign, avg_up_move, avg_down_move,
                            expected_return, created_at
                        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW())
                        ON CONFLICT (pattern_name, market_symbol, timing_type) DO NOTHING
                    """, (
                        f"{request.market_name}_DAILY",
                        request.timing_type,
                        f"Moon conjunct Jupiter for {request.market_name} (Test)",
                        0.72,
                        8,  # total_occurrences
                        6,  # up_count
                        2,  # down_count
                        "up",  # prediction
                        "lunar_transit",  # pattern_type
                        "conjunction",  # aspect_type
                        "Jupiter",  # target_planet
                        "Aquarius",  # target_sign
                        "Pisces",  # moon_sign
                        2.3,  # avg_up_move
                        -1.1,  # avg_down_move
                        1.6  # expected_return
                    ))
                    conn.commit()

                    # Get results summary
                    cursor.execute("""
                        SELECT COUNT(*), MAX(accuracy_rate),
                               (SELECT pattern_name FROM lunar_patterns
                                WHERE market_symbol = %s AND timing_type = %s
                                ORDER BY accuracy_rate DESC LIMIT 1)
                        FROM lunar_patterns
                        WHERE market_symbol = %s AND timing_type = %s
                    """, (f"{request.market_name}_DAILY", request.timing_type,
                          f"{request.market_name}_DAILY", request.timing_type))

                    result = cursor.fetchone()
                    patterns_found = result[0] if result else 0
                    best_accuracy = float(result[1]) if result and result[1] else 0.0
                    best_pattern_name = result[2] if result and result[2] else None

                    cursor.close()
                    conn.close()

                    execution_time = (datetime.now() - start_time).total_seconds()

                    active_requests[request_id].update({
                        "status": "completed",
                        "message": f"Analysis completed successfully. Found {patterns_found} patterns.",
                        "patterns_found": patterns_found,
                        "best_pattern": {
                            "name": best_pattern_name,
                            "accuracy": best_accuracy
                        } if best_pattern_name else None,
                        "execution_time": execution_time
                    })

                    logger.info(f"✅ Completed backtest {request_id}: {patterns_found} patterns found")

                except Exception as e:
                    logger.error(f"❌ Backtest {request_id} failed: {e}")
                    active_requests[request_id].update({
                        "status": "failed",
                        "message": f"Analysis failed: {str(e)}"
                    })

            if __name__ == "__main__":
                import uvicorn
                uvicorn.run("backtesting_service:app", host="0.0.0.0", port=8000, log_level="info")
            PYTHON_EOF

            # Start the service
            echo "🌙 Starting FastAPI backtesting service on port 8000..."
            cd /app
            python backtesting_service.py

        env:
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-host
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-user
        - name: DB_NAME
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-name
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: market-encoder-secrets
              key: db-password
        - name: DB_PORT
          value: "5432"

        # Health checks
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3

        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3

        # Resource limits
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"

      restartPolicy: Always

---
# Service to expose the backtesting service
apiVersion: v1
kind: Service
metadata:
  name: backtesting-service
  namespace: time-series-indexing
  labels:
    app: backtesting-service
spec:
  type: ClusterIP
  ports:
  - port: 8000
    targetPort: 8000
    protocol: TCP
    name: http
  selector:
    app: backtesting-service